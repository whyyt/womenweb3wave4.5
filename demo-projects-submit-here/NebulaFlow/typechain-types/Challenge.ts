/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export interface ChallengeInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "aliveCount"
      | "checkIn"
      | "createdAt"
      | "creator"
      | "currentRound"
      | "depositAmount"
      | "description"
      | "endTime"
      | "forceEnd"
      | "forceStart"
      | "getParticipantInfo"
      | "getParticipants"
      | "getSummary"
      | "getTimeInfo"
      | "joinChallenge"
      | "maxParticipants"
      | "participantCount"
      | "poolBalance"
      | "rewardPerWinner"
      | "roundDuration"
      | "settledAt"
      | "startTime"
      | "status"
      | "title"
      | "totalRounds"
      | "viewStatus"
      | "winnersCount"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "CheckIn"
      | "Distributed"
      | "Eliminated"
      | "ParticipantJoined"
      | "Settled"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "aliveCount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "checkIn", values?: undefined): string;
  encodeFunctionData(functionFragment: "createdAt", values?: undefined): string;
  encodeFunctionData(functionFragment: "creator", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "currentRound",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "depositAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "description",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "endTime", values?: undefined): string;
  encodeFunctionData(functionFragment: "forceEnd", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "forceStart",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getParticipantInfo",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getParticipants",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSummary",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTimeInfo",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "joinChallenge",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "maxParticipants",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "participantCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "poolBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rewardPerWinner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "roundDuration",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "settledAt", values?: undefined): string;
  encodeFunctionData(functionFragment: "startTime", values?: undefined): string;
  encodeFunctionData(functionFragment: "status", values?: undefined): string;
  encodeFunctionData(functionFragment: "title", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "totalRounds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "viewStatus",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "winnersCount",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "aliveCount", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "checkIn", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "createdAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "creator", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "currentRound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "description",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "endTime", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "forceEnd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "forceStart", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getParticipantInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getParticipants",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getSummary", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTimeInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "joinChallenge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxParticipants",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "participantCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "poolBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardPerWinner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "roundDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "settledAt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "startTime", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "status", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "title", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "totalRounds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "viewStatus", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "winnersCount",
    data: BytesLike
  ): Result;
}

export namespace CheckInEvent {
  export type InputTuple = [
    user: AddressLike,
    day: BigNumberish,
    timestamp: BigNumberish
  ];
  export type OutputTuple = [user: string, day: bigint, timestamp: bigint];
  export interface OutputObject {
    user: string;
    day: bigint;
    timestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DistributedEvent {
  export type InputTuple = [total: BigNumberish, perUser: BigNumberish];
  export type OutputTuple = [total: bigint, perUser: bigint];
  export interface OutputObject {
    total: bigint;
    perUser: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace EliminatedEvent {
  export type InputTuple = [user: AddressLike, missedRound: BigNumberish];
  export type OutputTuple = [user: string, missedRound: bigint];
  export interface OutputObject {
    user: string;
    missedRound: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ParticipantJoinedEvent {
  export type InputTuple = [user: AddressLike, totalParticipants: BigNumberish];
  export type OutputTuple = [user: string, totalParticipants: bigint];
  export interface OutputObject {
    user: string;
    totalParticipants: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SettledEvent {
  export type InputTuple = [
    winners: BigNumberish,
    rewardPerWinner: BigNumberish
  ];
  export type OutputTuple = [winners: bigint, rewardPerWinner: bigint];
  export interface OutputObject {
    winners: bigint;
    rewardPerWinner: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface Challenge extends BaseContract {
  connect(runner?: ContractRunner | null): Challenge;
  waitForDeployment(): Promise<this>;

  interface: ChallengeInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  aliveCount: TypedContractMethod<[], [bigint], "view">;

  checkIn: TypedContractMethod<[], [void], "nonpayable">;

  createdAt: TypedContractMethod<[], [bigint], "view">;

  creator: TypedContractMethod<[], [string], "view">;

  currentRound: TypedContractMethod<[], [bigint], "view">;

  depositAmount: TypedContractMethod<[], [bigint], "view">;

  description: TypedContractMethod<[], [string], "view">;

  endTime: TypedContractMethod<[], [bigint], "view">;

  forceEnd: TypedContractMethod<[], [void], "nonpayable">;

  forceStart: TypedContractMethod<[], [void], "nonpayable">;

  getParticipantInfo: TypedContractMethod<
    [user: AddressLike],
    [
      [boolean, boolean, bigint, boolean, boolean, boolean, boolean] & {
        joined: boolean;
        eliminated: boolean;
        lastCheckInRound: bigint;
        rewardClaimed: boolean;
        isWinner: boolean;
        hasCheckedIn: boolean;
        isCompleted: boolean;
      }
    ],
    "view"
  >;

  getParticipants: TypedContractMethod<[], [string[]], "view">;

  getSummary: TypedContractMethod<
    [],
    [
      [
        string,
        string,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint
      ]
    ],
    "view"
  >;

  getTimeInfo: TypedContractMethod<
    [],
    [
      [bigint, bigint, boolean, boolean] & {
        currentRoundNumber: bigint;
        endTimestamp: bigint;
        started: boolean;
        finished: boolean;
      }
    ],
    "view"
  >;

  joinChallenge: TypedContractMethod<[], [void], "payable">;

  maxParticipants: TypedContractMethod<[], [bigint], "view">;

  participantCount: TypedContractMethod<[], [bigint], "view">;

  poolBalance: TypedContractMethod<[], [bigint], "view">;

  rewardPerWinner: TypedContractMethod<[], [bigint], "view">;

  roundDuration: TypedContractMethod<[], [bigint], "view">;

  settledAt: TypedContractMethod<[], [bigint], "view">;

  startTime: TypedContractMethod<[], [bigint], "view">;

  status: TypedContractMethod<[], [bigint], "view">;

  title: TypedContractMethod<[], [string], "view">;

  totalRounds: TypedContractMethod<[], [bigint], "view">;

  viewStatus: TypedContractMethod<[], [bigint], "view">;

  winnersCount: TypedContractMethod<[], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "aliveCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "checkIn"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "createdAt"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "creator"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "currentRound"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "depositAmount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "description"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "endTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "forceEnd"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "forceStart"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getParticipantInfo"
  ): TypedContractMethod<
    [user: AddressLike],
    [
      [boolean, boolean, bigint, boolean, boolean, boolean, boolean] & {
        joined: boolean;
        eliminated: boolean;
        lastCheckInRound: bigint;
        rewardClaimed: boolean;
        isWinner: boolean;
        hasCheckedIn: boolean;
        isCompleted: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getParticipants"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "getSummary"
  ): TypedContractMethod<
    [],
    [
      [
        string,
        string,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint
      ]
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getTimeInfo"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, boolean, boolean] & {
        currentRoundNumber: bigint;
        endTimestamp: bigint;
        started: boolean;
        finished: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "joinChallenge"
  ): TypedContractMethod<[], [void], "payable">;
  getFunction(
    nameOrSignature: "maxParticipants"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "participantCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "poolBalance"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "rewardPerWinner"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "roundDuration"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "settledAt"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "startTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "status"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "title"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "totalRounds"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "viewStatus"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "winnersCount"
  ): TypedContractMethod<[], [bigint], "view">;

  getEvent(
    key: "CheckIn"
  ): TypedContractEvent<
    CheckInEvent.InputTuple,
    CheckInEvent.OutputTuple,
    CheckInEvent.OutputObject
  >;
  getEvent(
    key: "Distributed"
  ): TypedContractEvent<
    DistributedEvent.InputTuple,
    DistributedEvent.OutputTuple,
    DistributedEvent.OutputObject
  >;
  getEvent(
    key: "Eliminated"
  ): TypedContractEvent<
    EliminatedEvent.InputTuple,
    EliminatedEvent.OutputTuple,
    EliminatedEvent.OutputObject
  >;
  getEvent(
    key: "ParticipantJoined"
  ): TypedContractEvent<
    ParticipantJoinedEvent.InputTuple,
    ParticipantJoinedEvent.OutputTuple,
    ParticipantJoinedEvent.OutputObject
  >;
  getEvent(
    key: "Settled"
  ): TypedContractEvent<
    SettledEvent.InputTuple,
    SettledEvent.OutputTuple,
    SettledEvent.OutputObject
  >;

  filters: {
    "CheckIn(address,uint256,uint256)": TypedContractEvent<
      CheckInEvent.InputTuple,
      CheckInEvent.OutputTuple,
      CheckInEvent.OutputObject
    >;
    CheckIn: TypedContractEvent<
      CheckInEvent.InputTuple,
      CheckInEvent.OutputTuple,
      CheckInEvent.OutputObject
    >;

    "Distributed(uint256,uint256)": TypedContractEvent<
      DistributedEvent.InputTuple,
      DistributedEvent.OutputTuple,
      DistributedEvent.OutputObject
    >;
    Distributed: TypedContractEvent<
      DistributedEvent.InputTuple,
      DistributedEvent.OutputTuple,
      DistributedEvent.OutputObject
    >;

    "Eliminated(address,uint256)": TypedContractEvent<
      EliminatedEvent.InputTuple,
      EliminatedEvent.OutputTuple,
      EliminatedEvent.OutputObject
    >;
    Eliminated: TypedContractEvent<
      EliminatedEvent.InputTuple,
      EliminatedEvent.OutputTuple,
      EliminatedEvent.OutputObject
    >;

    "ParticipantJoined(address,uint256)": TypedContractEvent<
      ParticipantJoinedEvent.InputTuple,
      ParticipantJoinedEvent.OutputTuple,
      ParticipantJoinedEvent.OutputObject
    >;
    ParticipantJoined: TypedContractEvent<
      ParticipantJoinedEvent.InputTuple,
      ParticipantJoinedEvent.OutputTuple,
      ParticipantJoinedEvent.OutputObject
    >;

    "Settled(uint256,uint256)": TypedContractEvent<
      SettledEvent.InputTuple,
      SettledEvent.OutputTuple,
      SettledEvent.OutputObject
    >;
    Settled: TypedContractEvent<
      SettledEvent.InputTuple,
      SettledEvent.OutputTuple,
      SettledEvent.OutputObject
    >;
  };
}
